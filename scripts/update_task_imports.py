#!/usr/bin/env python3

#              M""""""""`M            dP
#              Mmmmmm   .M            88
#              MMMMP  .MMM  dP    dP  88  .dP   .d8888b.
#              MMP  .MMMMM  88    88  88888"    88'  `88
#              M' .MMMMMMM  88.  .88  88  `8b.  88.  .88
#              M         M  `88888P'  dP   `YP  `88888P'
#              MMMMMMMMMMM    -*-  Created by Zuko  -*-
#
#              * * * * * * * * * * * * * * * * * * * * *
#              * -    - -   F.R.E.E.M.I.N.D   - -    - *
#              * -  Copyright Â© 2025 (Z) Programing  - *
#              *    -  -  All Rights Reserved  -  -    *
#              * * * * * * * * * * * * * * * * * * * * *

#
"""
Update the imports in the __init__.py files for tasks and task steps.
This script should be run after creating new tasks or task steps to ensure they are importable.
"""

import re
from pathlib import Path


def update_tasks_init():
    """Update the tasks/__init__.py file to import all task classes"""
    base_path = Path(__file__).parent.parent
    tasks_dir = base_path / 'tasks'
    init_file = tasks_dir / '__init__.py'
    
    # Ensure the tasks directory exists
    if not tasks_dir.exists():
        print(f"Tasks directory not found: {tasks_dir}")
        return
    
    # Get all task files
    task_files = [f for f in tasks_dir.glob('*.py')
                  if f.name != '__init__.py' and not f.name.startswith('_')]
    
    # Extract class names from task files
    task_classes = []
    for file in task_files:
        with open(file, 'r') as f:
            content = f.read()
            class_match = re.search(r'class\s+(\w+)', content)
            if class_match:
                task_classes.append(class_match.group(1))
    
    # Generate new init file content
    content = [
        '# Tasks package - Auto-generated imports',
        '# Do not edit this file manually, use update_task_imports.py script instead',
        '',
    ]
    
    # Imports
    for file in task_files:
        module_name = file.stem
        class_name = module_name  # Assuming class name matches file name (minus the .py)
        content.append(f'from tasks.{module_name} import {class_name}')
    
    # Add __all__ declaration
    if task_classes:
        content.append('')
        content.append('__all__ = [')
        for cls in task_classes:
            content.append(f'    "{cls}",')
        content.append(']')
    
    # Write the new init file
    with open(init_file, 'w') as f:
        f.write('\n'.join(content))
    
    print(f"Updated {init_file} with {len(task_classes)} task imports")


def update_steps_init():
    """Update the tasks/steps/__init__.py file to import all step classes"""
    base_path = Path(__file__).parent.parent
    steps_dir = base_path / 'tasks' / 'steps'
    init_file = steps_dir / '__init__.py'
    
    # Ensure the steps directory exists
    if not steps_dir.exists():
        print(f"Steps directory not found: {steps_dir}")
        return
    
    # Get all step files
    step_files = [f for f in steps_dir.glob('*.py')
                  if f.name != '__init__.py' and not f.name.startswith('_')]
    
    # Extract class names from step files
    step_classes = []
    for file in step_files:
        with open(file, 'r') as f:
            content = f.read()
            class_match = re.search(r'class\s+(\w+)', content)
            if class_match:
                step_classes.append(class_match.group(1))
    
    # Generate new init file content
    content = [
        '# Task steps package - Auto-generated imports',
        '# Do not edit this file manually, use update_task_imports.py script instead',
        '',
    ]
    
    # Imports
    for file in step_files:
        module_name = file.stem
        class_name = module_name  # Assuming class name matches file name (minus the .py)
        content.append(f'from tasks.steps.{module_name} import {class_name}')
    
    # Add __all__ declaration
    if step_classes:
        content.append('')
        content.append('__all__ = [')
        for cls in step_classes:
            content.append(f'    "{cls}",')
        content.append(']')
    
    # Write the new init file
    with open(init_file, 'w') as f:
        f.write('\n'.join(content))
    
    print(f"Updated {init_file} with {len(step_classes)} step imports")


def update_core_task_system():
    """Update core/TaskSystem.py to import custom tasks and steps"""
    # NOTE: This is a more advanced feature and would require parsing the file carefully
    # For now, we'll just print a reminder for manual updates
    print("NOTE: You may want to update core/TaskSystem.py manually to import your custom tasks and steps")
    print("Example: from tasks import MyCustomTask")
    print("Example: from tasks.steps import MyCustomStep")


def main():
    update_tasks_init()
    update_steps_init()
    update_core_task_system()
    print("Task imports updated successfully!")


if __name__ == '__main__':
    main()
