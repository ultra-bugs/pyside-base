#                  M""""""`M            dP
#                  Mmmmmm   .M            88
#                  MMMMP  .MMM  dP    dP  88  .dP   .d8888b.
#                  MMP  .MMMMM  88    88  88888"    88'  `88
#                  M' .MMMMMMM  88.  .88  88  `8b.  88.  .88
#                  M         M  `88888P'  dP   `YP  `88888P'
#                  MMMMMMMMMMM    -*-  Created by Zuko  -*-
#
#                  * * * * * * * * * * * * * * * * * * * * *
#                  * -    - -   F.R.E.E.M.I.N.D   - -    - *
#                  * -  Copyright © 2026 (Z) Programing  - *
#                  *    -  -  All Rights Reserved  -  -    *
#                  * * * * * * * * * * * * * * * * * * * * *

"""
Build-time script: scan app/providers/ and generate _provider_manifest.py.

Uses AST parsing to find ServiceProvider subclasses without importing them.
Run: pixi run compile-providers
"""

import ast
import sys
from pathlib import Path


def findProviderClasses(filePath: Path) -> list:
    """Parse a Python file and find classes that subclass ServiceProvider.
    
    Returns list of tuples: (className, discoverable)
    """
    source = filePath.read_text(encoding='utf-8')
    tree = ast.parse(source, filename=str(filePath))
    providers = []
    for node in ast.walk(tree):
        if not isinstance(node, ast.ClassDef):
            continue
        # Check if any base class references ServiceProvider
        isProvider = False
        for base in node.bases:
            baseName = ''
            if isinstance(base, ast.Name):
                baseName = base.id
            elif isinstance(base, ast.Attribute):
                baseName = base.attr
            if baseName == 'ServiceProvider':
                isProvider = True
                break
        if not isProvider:
            continue
        # Check discoverable attribute (default True)
        discoverable = True
        for item in node.body:
            if isinstance(item, ast.Assign):
                for target in item.targets:
                    if isinstance(target, ast.Name) and target.id == 'discoverable':
                        if isinstance(item.value, ast.Constant):
                            discoverable = item.value.value
        if discoverable:
            providers.append(node.name)
    return providers


def main():
    projectRoot = Path(__file__).parent.parent
    providersDir = projectRoot / 'app' / 'providers'
    
    if not providersDir.exists():
        print(f'[compile_providers] No providers directory found: {providersDir}')
        print('[compile_providers] Skipping manifest generation.')
        return
    
    allProviders = []
    
    for pyFile in sorted(providersDir.glob('*Provider.py')):
        if pyFile.name.startswith('_'):
            continue
        moduleName = f'app.providers.{pyFile.stem}'
        try:
            classNames = findProviderClasses(pyFile)
            for className in classNames:
                fqn = f'{moduleName}.{className}'
                allProviders.append(fqn)
                print(f'  Found: {fqn}')
        except Exception as e:
            print(f'  ERROR parsing {pyFile.name}: {e}', file=sys.stderr)
    
    # Write manifest
    manifestPath = providersDir / '_provider_manifest.py'
    lines = [
        '# Auto-generated by scripts/compile_providers.py',
        '# Do NOT edit manually — run: pixi run compile-providers',
        '',
        'PROVIDERS = [',
    ]
    for fqn in allProviders:
        lines.append(f"    '{fqn}',")
    lines.append(']')
    lines.append('')
    
    manifestPath.write_text('\n'.join(lines), encoding='utf-8')
    print(f'[compile_providers] Generated {manifestPath} with {len(allProviders)} provider(s)')


if __name__ == '__main__':
    main()
